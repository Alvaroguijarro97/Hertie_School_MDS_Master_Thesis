---
title: "Primary and Secondary Education"
author: "Alvaro Guijarro"
date: "`r Sys.Date()`"
output: html_document
---

```{r Libraries}
library(readxl)
library(dplyr)
library(ggplot2)
library(readxl)
library(writexl)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(plotly)
library(zoo)
library(tidyr)
library(purrr)
library(lubridate)
```

```{r Read Dataset}
dataset <- read_excel("MEN_ESTADISTICAS_EN_EDUCACION_EN_PREESCOLAR__B_SICA_Y_MEDIA_POR_MUNICIPIO_20240221.xlsx")

cleaned_dataset <- dataset %>%
  select(AÑO, CÓDIGO_MUNICIPIO, MUNICIPIO, TASA_MATRICULACIÓN_5_16, COBERTURA_NETA, COBERTURA_NETA_TRANSICIÓN, COBERTURA_NETA_PRIMARIA, COBERTURA_NETA_SECUNDARIA, COBERTURA_NETA_MEDIA, DESERCIÓN, DESERCIÓN_TRANSICIÓN, DESERCIÓN_PRIMARIA, DESERCIÓN_SECUNDARIA, DESERCIÓN_MEDIA, APROBACIÓN, APROBACIÓN_TRANSICIÓN, APROBACIÓN_PRIMARIA, APROBACIÓN_SECUNDARIA, APROBACIÓN_MEDIA, REPROBACIÓN, REPROBACIÓN_TRANSICIÓN, REPROBACIÓN_PRIMARIA, REPROBACIÓN_SECUNDARIA, REPROBACIÓN_MEDIA) %>%
  filter(CÓDIGO_MUNICIPIO %in% c(8001, 11001, 68001, 76001, 13001, 54001, 73001, 17001, 5001, 23001, 52001, 66001, 50001))
```
Let's transform the "Municipio" names so they match out other datasets, and change the column names to english. 

```{r}
unique(cleaned_dataset$MUNICIPIO)
municipio_transform <- c(
  "Barranquilla" = "BARRANQUILLA A.M.",
  "Bogotá D.C." = "BOGOTÁ D.C.",
  "Bogotá, D.C." = "BOGOTÁ D.C.",
  "Bucaramanga" = "BUCARAMANGA A.M.",
  "Cali" = "CALI A.M.",
  "Cartagena" = "CARTAGENA",
  "Cúcuta" = "CÚCUTA A.M.",
  "Ibagué" = "IBAGUÉ",
  "Manizales" = "MANIZALES A.M.",
  "Medellín" = "MEDELLÍN A.M.",
  "Montería" = "MONTERÍA",
  "Pasto" = "PASTO",
  "Pereira" = "PEREIRA A.M.",
  "Villavicencio" = "VILLAVICENCIO"
)
cleaned_dataset <- cleaned_dataset %>%
  mutate(MUNICIPIO = recode(MUNICIPIO, !!!municipio_transform))  %>%
  arrange(MUNICIPIO, AÑO) %>%
  rename( year = AÑO, 
          city_id = CÓDIGO_MUNICIPIO,
          city = MUNICIPIO,
          Enrollment_Rate_5_16 = TASA_MATRICULACIÓN_5_16, # Proporción de la población entre 5 y 16 años que se encuentra asistiendo al sistema educativo. Cuando las proyecciones de población del DANE no capturan adecuadamente los flujos migratorios internos, puede alcanzar valores mayores al 100%.
          Net_Coverage = COBERTURA_NETA, # Es la relación entre el número de estudiantes matriculados en transición, primaria, secundaria y media que tienen la edad teórica (5 a 16 años) y el total de la población correspondiente a esa misma edad. Cuando las proyecciones de población del DANE no capturan adecuadamente los flujos migratorios internos, puede alcanzar valores mayores al 100%
          Net_Coverage_Transition = COBERTURA_NETA_TRANSICIÓN, # Es la relación entre el número de estudiantes matriculados en transición que tienen la edad teórica para cursar este nivel (5 años) y el total de la población correspondiente a esa misma edad. Cuando las proyecciones de población del DANE no capturan adecuadamente los flujos migratorios internos, puede alcanzar valores mayores al 100%.
          Net_Coverage_Primary = COBERTURA_NETA_PRIMARIA, # Es la relación entre el número de estudiantes matriculados en primaria que tienen la edad teórica para cursar este nivel (6 a 10 años) y el total de la población correspondiente a esa misma edad. Cuando las proyecciones de población del DANE no capturan adecuadamente los flujos migratorios internos, puede alcanzar valores mayores al 100%.
          Net_Coverage_Secondary = COBERTURA_NETA_SECUNDARIA, # Es la relación entre el número de estudiantes matriculados en secundaria que tienen la edad teórica para cursar este nivel (11 a 14 años) y el total de la población correspondiente a esa misma edad. Cuando las proyecciones de población del DANE no capturan adecuadamente los flujos migratorios internos, puede alcanzar valores mayores al 100%.
          Net_Coverage_HighSchool = COBERTURA_NETA_MEDIA, # Es la relación entre el número de estudiantes matriculados en media que tienen la edad teórica para cursar este nivel (15 a 16 años) y el total de la población correspondiente a esa misma edad. Cuando las proyecciones de población del DANE no capturan adecuadamente los flujos migratorios internos, puede alcanzar valores mayores al 100%.
          Dropout_Rate = DESERCIÓN, # Tasa de deserción intra - anual del sector oficial. Identifica la proporción de alumnos matriculados que por factores culturales, coyunturales o de prestación del servicio educativo, abandonan sus estudios durante el año lectivo.
          Dropout_Rate_Transition = DESERCIÓN_TRANSICIÓN, # Tasa de deserción intra - anual del sector oficial en transición. Identifica la proporción de alumnos matriculados que por factores culturales, coyunturales o de prestación del servicio educativo, abandonan sus estudios durante el año lectivo.
          Dropout_Rate_Primary = DESERCIÓN_PRIMARIA,# Tasa de deserción intra - anual del sector oficial en primaria. Identifica la proporción de alumnos matriculados que por factores culturales, coyunturales o de prestación del servicio educativo, abandonan sus estudios durante el año lectivo.
          Dropout_Rate_Secondary = DESERCIÓN_SECUNDARIA, # Tasa de deserción intra - anual del sector oficial en secundaria. Identifica la proporción de alumnos matriculados que por factores culturales, coyunturales o de prestación del servicio educativo, abandonan sus estudios durante el año lectivo.
          Dropout_Rate_HighSchool = DESERCIÓN_MEDIA, # Tasa de deserción intra - anual del sector oficial en media. Identifica la proporción de alumnos matriculados que por factores culturales, coyunturales o de prestación del servicio educativo, abandonan sus estudios durante el año lectivo.
          Pass_Rate = APROBACIÓN, # Tasa de aprobación de estudiantes del sector oficial. Identifica el porcentaje de alumnos en educación preescolar, básica y media que aprueba de acuerdo con los planes y programas de estudio vigentes.
          Pass_Rate_Transition = APROBACIÓN_TRANSICIÓN,# Tasa de aprobación de estudiantes del sector oficial en transición. Identifica el porcentaje de alumnos en este nivel educativo que aprueba de acuerdo con los planes y programas de estudio vigentes.
          Pass_Rate_Primary = APROBACIÓN_PRIMARIA,# Tasa de aprobación de estudiantes del sector oficial en primaria. Identifica el porcentaje de alumnos en este nivel educativo que aprueba de acuerdo con los planes y programas de estudio vigentes.
          Pass_Rate_Secondary = APROBACIÓN_SECUNDARIA,# Tasa de aprobación de estudiantes del sector oficial en secundaria. Identifica el porcentaje de alumnos en este nivel educativo que aprueba de acuerdo con los planes y programas de estudio vigentes.
          Pass_Rate_HighSchool = APROBACIÓN_MEDIA,# Tasa de aprobación de estudiantes del sector oficial en media. Identifica el porcentaje de alumnos en este nivel educativo que aprueba de acuerdo con los planes y programas de estudio vigentes.
          Fail_Rate = REPROBACIÓN, # Tasa de reprobación de estudiantes del sector oficial. Identifica el porcentaje de alumnos en educación preescolar, básica y media que reprueba de acuerdo con los planes y programas de estudio vigentes.
          Fail_Rate_Transition = REPROBACIÓN_TRANSICIÓN,#Tasa de reprobación de estudiantes del sector oficial en transición. Identifica el porcentaje de alumnos en este nivel educativo que reprueba de acuerdo con los planes y programas de estudio vigentes.
          Fail_Rate_Primary = REPROBACIÓN_PRIMARIA, #Tasa de reprobación de estudiantes del sector oficial en primaria. Identifica el porcentaje de alumnos en este nivel educativo que reprueba de acuerdo con los planes y programas de estudio vigentes.
          Fail_Rate_Secondary = REPROBACIÓN_SECUNDARIA, #Tasa de repitencia del sector oficial. Corresponde al porcentaje de alumnos matriculados en secundaria que se encuentran repitiendo el mismo grado cursado el año anterior.
          Fail_Rate_HighSchool = REPROBACIÓN_MEDIA# Tasa de repitencia del sector oficial. Corresponde al porcentaje de alumnos matriculados en media que se encuentran repitiendo el mismo grado cursado el año anterior.
    )

unique(cleaned_dataset$city)

#Set the "AÑO" Column to date variable and "Municipio" as chr
cleaned_dataset$city <- as.character(cleaned_dataset$city)

```
```{r check NA's}
na_counts <- cleaned_dataset %>%
  summarise_all(~sum(is.na(.)))

# Print the NA counts
print(na_counts)
```
```{r}
# Function to interpolate all specified columns for a single city
interpolate_city <- function(data_city, columns_to_interpolate) {
  if (nrow(data_city) > 0) {
    # Assume city name and city_id are the same for all rows, as it's grouped
    city_name <- unique(data_city$city)[1]
    city_id <- unique(data_city$city_id)[1]
    
    # Create an annual time series with NA handling
    annual_dates <- as.Date(paste(data_city$year, "-12-01", sep = ""))
    
    # Create a sequence of monthly dates from the start to the end of the series
    monthly_dates <- seq(from = min(annual_dates), to = max(annual_dates), by = "1 month")
    
    # Initialize the monthly data with the correct number of rows
    monthly_data <- data.frame(
      city = rep(city_name, length(monthly_dates)),
      city_id = rep(city_id, length(monthly_dates)),
      date = monthly_dates,
      year = format(monthly_dates, "%Y"),
      month = format(monthly_dates, "%m")
    )
    
    for (col in columns_to_interpolate) {
      # Get the original non-NA values to enforce the min/max for interpolation
      original_values <- na.omit(data_city[[col]])
      min_val <- min(original_values)
      max_val <- max(original_values)
      
      # Create an annual time series for the current column
      annual_series <- zoo(data_city[[col]], order.by = annual_dates)
      
      # Use na.approx to fill in leading/trailing NAs linearly
      annual_series_filled <- na.approx(annual_series, x = annual_dates, method = "linear", na.rm = FALSE)
      
      # Perform spline interpolation with boundaries
      spline_interpolated <- spline(annual_dates, annual_series_filled, xout = monthly_dates, method = "fmm")$y
      
      # Enforce the min/max bounds
      monthly_series <- pmax(pmin(spline_interpolated, max_val), min_val)
      
      # Add the monthly series to the monthly data
      monthly_data[[col]] <- monthly_series
    }
    
    return(monthly_data)
  } else {
    return(data.frame()) # Return an empty data.frame if there is no data
  }
}

# Define the columns to interpolate
columns_to_interpolate <- c("Enrollment_Rate_5_16", "Net_Coverage", "Net_Coverage_Transition", 
                            "Net_Coverage_Primary", "Net_Coverage_Secondary", "Net_Coverage_HighSchool", 
                            "Dropout_Rate", "Dropout_Rate_Transition", "Dropout_Rate_Primary", 
                            "Dropout_Rate_Secondary", "Dropout_Rate_HighSchool", "Pass_Rate", 
                            "Pass_Rate_Transition", "Pass_Rate_Primary", "Pass_Rate_Secondary", 
                            "Pass_Rate_HighSchool", "Fail_Rate", "Fail_Rate_Transition", 
                            "Fail_Rate_Primary", "Fail_Rate_Secondary", "Fail_Rate_HighSchool")

# Apply the interpolation to each city and combine the results
monthly_data <- cleaned_dataset %>%
  group_by(city, city_id) %>%
  group_map(~interpolate_city(.x, columns_to_interpolate), .keep = TRUE) %>%
  bind_rows()

#Filter the data by date range
monthly_data <- monthly_data %>%
   filter(date >= as.Date("2010-12-01") & date <= as.Date("2023-12-31"))
head(monthly_data)
```
Plot the different variables:
```{r}
# Create the interactive plot directly with plotly
plotly_obj <- plot_ly(data = monthly_data, x = ~date, y = ~Enrollment_Rate_5_16, 
                      color = ~city, colors = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
                      type = 'scatter', mode = 'lines+markers',
                      text = ~city, hoverinfo = 'text+x+y') %>%
  layout(title = "% of 5 - 16 Year old in School by City from 2011 to 2022",
         xaxis = list(title = "Year"),
         yaxis = list(title = "% of 5 - 16 Year old", tickformat = ",d", 
                      range = c(0, max(monthly_data$Enrollment_Rate_5_16, na.rm = TRUE))),
         legend = list(orientation = "v", x = 1.05, y = 1))

# Display the interactive plot
plotly_obj
```

```{r}
# Define the list of variables to loop over
variables_list <- c("Enrollment_Rate_5_16", "Net_Coverage", "Net_Coverage_Transition", 
                    "Net_Coverage_Primary", "Net_Coverage_Secondary", "Net_Coverage_HighSchool", 
                    "Dropout_Rate", "Dropout_Rate_Transition", "Dropout_Rate_Primary", 
                    "Dropout_Rate_Secondary", "Dropout_Rate_HighSchool", "Pass_Rate", 
                    "Pass_Rate_Transition", "Pass_Rate_Primary", "Pass_Rate_Secondary", 
                    "Pass_Rate_HighSchool", "Fail_Rate", "Fail_Rate_Transition", 
                    "Fail_Rate_Primary", "Fail_Rate_Secondary", "Fail_Rate_HighSchool")

# Loop over each variable and create a plot
plot_list <- lapply(variables_list, function(variable) {
  y_title <- paste("Percentage of", gsub("_", " ", variable))
  plot_title <- paste(y_title, "by City from 2011 to 2022")
  
  plot_ly(data = monthly_data, x = ~date, y = as.formula(paste0("~`", variable, "`")),
          color = ~city, colors = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
          type = 'scatter', mode = 'lines+markers',
          text = ~city, hoverinfo = 'text+x+y') %>%
    layout(title = plot_title,
           xaxis = list(title = "Year"),
           yaxis = list(title = y_title, tickformat = ",d",
                        range = c(0, max(monthly_data[[variable]], na.rm = TRUE) + 10)),
           legend = list(orientation = "v", x = 1.05, y = 1))
})

# Print the plots
for (plot in plot_list) {
  print(plot)
}
```

Let's identify the different end of the year data points to see how did the interpolation went like.

```{r}
# Add a new column to identify December months
monthly_data$Is_December <- format(monthly_data$date, "%m") == "12"

# Define the list of variables to loop over
variables_list <- c("Enrollment_Rate_5_16", "Net_Coverage", "Net_Coverage_Transition", 
                    "Net_Coverage_Primary", "Net_Coverage_Secondary", "Net_Coverage_HighSchool", 
                    "Dropout_Rate", "Dropout_Rate_Transition", "Dropout_Rate_Primary", 
                    "Dropout_Rate_Secondary", "Dropout_Rate_HighSchool", "Pass_Rate", 
                    "Pass_Rate_Transition", "Pass_Rate_Primary", "Pass_Rate_Secondary", 
                    "Pass_Rate_HighSchool", "Fail_Rate", "Fail_Rate_Transition", 
                    "Fail_Rate_Primary", "Fail_Rate_Secondary", "Fail_Rate_HighSchool")

# Loop over each variable and create a plot
plot_list <- lapply(variables_list, function(variable) {
  # Filter the dataset for the variable
  data_variable <- monthly_data %>%
    select(city, date, value = .data[[variable]], Is_December)
  
  # Start the plot with non-December data
  p <- plot_ly(data = data_variable %>% filter(!Is_December), 
               x = ~date, y = ~value, 
               color = ~city, colors = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
               type = 'scatter', mode = 'lines+markers',
               text = ~city, hoverinfo = 'text+x+y') 
  
  # Add December data with black outlines
  p <- add_trace(p, data = data_variable %>% filter(Is_December), 
                 x = ~date, y = ~value,
                 marker = list(line = list(color = 'black', width = 2)),
                 type = 'scatter', mode = 'markers')

  # Layout settings
  p <- layout(p,
              title = paste("Monthly", gsub("_", " ", variable), "Evolution by City"),
              xaxis = list(title = "Date"),
              yaxis = list(title = paste(gsub("_", " ", variable), "(%)"),
                        range = c(0, max(monthly_data[[variable]], na.rm = TRUE) + 10)),
              legend = list(orientation = 'v', x = 1.05, y = 1))
  
  return(p)
})

# Print the plots
for (plot in plot_list) {
  print(plot)
}
```

```{r prepare for exporting}
# Define the columns to be transformed to percentages
percentage_columns <- c("Enrollment_Rate_5_16", "Net_Coverage", "Net_Coverage_Transition", 
                        "Net_Coverage_Primary", "Net_Coverage_Secondary", "Net_Coverage_HighSchool", 
                        "Dropout_Rate", "Dropout_Rate_Transition", "Dropout_Rate_Primary", 
                        "Dropout_Rate_Secondary", "Dropout_Rate_HighSchool", "Pass_Rate", 
                        "Pass_Rate_Transition", "Pass_Rate_Primary", "Pass_Rate_Secondary", 
                        "Pass_Rate_HighSchool", "Fail_Rate", "Fail_Rate_Transition", 
                        "Fail_Rate_Primary", "Fail_Rate_Secondary", "Fail_Rate_HighSchool")

# Transform the columns to percentages and set their type to double
final_monthly_data <- monthly_data %>%
  mutate(across(all_of(percentage_columns), ~ .x / 100, .names = "{.col}")) %>%
  mutate(across(all_of(percentage_columns), as.double, .names = "{.col}")) %>%
  # Format the date column to character with "%Y-%m" format
  mutate(date = format(date, "%Y-%m")) %>%
  # Select all columns except "Is_December"
  select(-Is_December)

# Print the head of the dataset to check the changes
head(final_monthly_data)
```
```{r export dataset}
# Extract the minimum and maximum dates from the dataset
min_date <- min(final_monthly_data$date)
max_date <- max(final_monthly_data$date)

# Create the filename using the min and max dates
filename <- paste0("Education_data_cleaned_", min_date, "-", max_date, ".xlsx")

# Write the dataframe to an Excel file
write_xlsx(final_monthly_data, filename)
```

