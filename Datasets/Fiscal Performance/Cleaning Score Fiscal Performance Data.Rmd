---
title: "Fiscal Performance data cleaning dataset"
author: "Alvaro Guijarro"
date: "`r Sys.Date()`"
output: html_document
---

```{r Libraries, include=Fase}
library(readxl)
library(dplyr)
library(tidyr)
library(tidyverse)
library(plotly)
library(lubridate)
library(ggplot2)
library(forecast)
library(stats)
library(tseries)
library(zoo)
library(writexl)
```

```{r read datasets}
sfp <- read_excel("Score_Fiscal_Performance_2015-2022.xlsx") 
#Resumen Indice Desempeño fiscal 2015-2022, puntajes del 1-100 / Summary of Fiscal Performance Index 2015-2022, scores from 1-100
head(sfp)
colnames(sfp)
```

```{r translating column names}
# Set new column names in English with explanations
colnames(sfp) <- c(
  "year", # Año: Year the score was calculated.
  "code", # Codigo: The unique code for each municipality
  "city", # Municipio: The name of the municipality.
  "Self-financing_of_operating_expenses", # 1/ Autofinanciación de los gastos de funcionamiento: Self-financing of operating expenses: the ability to cover the operating expenses of the central administration with unrestricted income (Law 617 of 2000)
  "Debt_service_support", #2/ Respaldo del servicio de la deuda: Debt service support: the ability to support debt service with perceived revenues.
  "Dependence_on_transfers_from_the_Nation_and_Royalties", #3/ Dependencia de las transferencias de la Nación y las Regalías: Dependence on transfers from the Nation and Royalties: measures the importance of national transfers and royalties (SGR) in total revenues.
  "Generation_of_Own_Resources", #4/ Generación de recursos propios:Generation of Own Resources: the ability to generate resources complementary to the transfers.
  "Magnitude_of_Investment", #5/ Magnitud de la inversión: Magnitude of Investment: quantifies the magnitude of the investment executed by the territorial entity.
  "Saving_Capacity", #6/ Capacidad de ahorro: Saving Capacity: determines the degree to which surpluses are freed up to finance investment.
  "Fiscal_Performance_Indicator", #7/ Indicador de desempeño Fiscal : 7_Fiscal_Performance_Indicator
  "Classification Range" #Rango Clasificación: Classification Range
 )
```

```{r }
unique(sfp$city)

# View the filtered dataset
head(sfp)

sfp_filtered <- sfp %>%
  arrange(city, year) %>%
  select(-code)

sfp_filtered
```

```{r visualize the data}
# Define the list of variables to loop over
variables_list <- c("Self-financing_of_operating_expenses","Debt_service_support","Dependence_on_transfers_from_the_Nation_and_Royalties","Generation_of_Own_Resources","Magnitude_of_Investment","Saving_Capacity","Fiscal_Performance_Indicator")

# Create the interactive plot directly with plotly
plotly_obj <- plot_ly(data = sfp_filtered, x = ~year, y = ~Fiscal_Performance_Indicator, 
                      color = ~city, colors = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
                      type = 'scatter', mode = 'lines+markers',
                      text = ~city, hoverinfo = 'text+x+y') %>%
  layout(title = "Fiscal Performance Score by City from 2015 to 2022",
         xaxis = list(title = "Year"),
         yaxis = list(title = "Score", 
                      range = c(0, 100, na.rm = TRUE)),
         legend = list(orientation = "v", x = 1.05, y = 1))

# Display the interactive plot
plotly_obj
```

```{r}
# Loop over each variable and create a plot
plot_list <- lapply(variables_list, function(variable) {
  # Filter the dataset for the variable
  data_variable <- sfp_filtered %>%
    select(city, year, value = .data[[variable]])
  
  # Start the plot with non-December data
  p <- plot_ly(data = data_variable, 
               x = ~year, y = ~value, 
               color = ~city, colors = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
               type = 'scatter', mode = 'lines+markers',
               text = ~city, hoverinfo = 'text+x+y') 

  # Layout settings
  p <- layout(p,
              title = paste(gsub("_", " ", variable), "Evolution by City"),
              xaxis = list(title = "Date"),
              yaxis = list(title = paste(gsub("_", " ", variable)),
                        range = c(0, max(sfp_filtered[[variable]], na.rm = TRUE))),
              legend = list(orientation = 'v', x = 1.05, y = 1))
  
  return(p)
})

# Print the plots
for (plot in plot_list) {
  print(plot)
}
```


Let's Interpolate the data to have it in a monthly basis
```{r}
# Function to interpolate all specified columns for a single city
interpolate_city <- function(data_city, columns_to_interpolate) {
  if (nrow(data_city) > 0) {
    city_name <- unique(data_city$city)[1]
    annual_dates <- as.Date(paste(data_city$year, "-12-01", sep = ""))
    monthly_dates <- seq(from = min(annual_dates), to = max(annual_dates), by = "1 month")
    
    monthly_data <- data.frame(
      city = rep(city_name, length(monthly_dates)),
      date = monthly_dates,
      year = format(monthly_dates, "%Y"),
      month = format(monthly_dates, "%m")
    )
    
    for (col in columns_to_interpolate) {
      # Get the original non-NA values to enforce the min/max for interpolation
      original_values <- na.omit(data_city[[col]])
      min_val <- min(original_values)
      max_val <- max(original_values)
      
      # Create an annual time series for the current column
      annual_series <- zoo(data_city[[col]], order.by = annual_dates)
      
      # Use na.approx to fill in leading/trailing NAs linearly
      annual_series_filled <- na.approx(annual_series, x = annual_dates, method = "linear", na.rm = FALSE)
      
      # Perform spline interpolation
      spline_interpolated <- spline(annual_dates, annual_series_filled, xout = monthly_dates, method = "fmm")$y
      
      # Enforce the min/max bounds
      monthly_series <- pmax(pmin(spline_interpolated, max_val), min_val)
      
      # Add the monthly series to the monthly data
      monthly_data[[col]] <- monthly_series
    }
    
    return(monthly_data)
  } else {
    return(data.frame()) # Return an empty data.frame if there is no data
  }
}

# Define the columns to interpolate
columns_to_interpolate <- c("Self-financing_of_operating_expenses","Debt_service_support","Dependence_on_transfers_from_the_Nation_and_Royalties","Generation_of_Own_Resources","Magnitude_of_Investment","Saving_Capacity","Fiscal_Performance_Indicator")

# Apply the interpolation to each city and combine the results
monthly_data <- sfp_filtered %>%
  group_by(city) %>%
  group_map(~interpolate_city(.x, columns_to_interpolate), .keep = TRUE) %>%
  bind_rows() %>%
  mutate(Category = case_when(
    Fiscal_Performance_Indicator > 80 ~ "Solvent >80 points",
    Fiscal_Performance_Indicator > 70 & Fiscal_Performance_Indicator <= 80 ~ "Sustainable between 70-80 points",
    Fiscal_Performance_Indicator > 60 & Fiscal_Performance_Indicator <= 70 ~ "Vulnerable between 60 and 70 points",
    Fiscal_Performance_Indicator > 40 & Fiscal_Performance_Indicator <= 60 ~ "At Risk between 40 and 60 points",
    Fiscal_Performance_Indicator <= 40 ~ "Deterioration <=40 points",
    TRUE ~ NA_character_ # For any case that doesn't fit the above, although this shouldn't happen with your scoring system
  ))

#Filter the data by date range
monthly_data <- monthly_data %>%
   filter(date >= as.Date("2015-12-01") & date <= as.Date("2023-12-31"))
head(monthly_data)
```
```{r}
# Add a new column to identify December months
monthly_data$Is_December <- format(monthly_data$date, "%m") == "12"

# Define the list of variables to loop over
variables_list <- c("Self-financing_of_operating_expenses","Debt_service_support","Dependence_on_transfers_from_the_Nation_and_Royalties","Generation_of_Own_Resources","Magnitude_of_Investment","Saving_Capacity","Fiscal_Performance_Indicator")

# Loop over each variable and create a plot
plot_list <- lapply(variables_list, function(variable) {
  # Filter the dataset for the variable
  data_variable <- monthly_data %>%
    select(city, date, value = .data[[variable]], Is_December)
  
  # Start the plot with non-December data
  p <- plot_ly(data = data_variable %>% filter(!Is_December), 
               x = ~date, y = ~value, 
               color = ~city, colors = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
               type = 'scatter', mode = 'lines+markers',
               text = ~city, hoverinfo = 'text+x+y') 
  
  # Add December data with black outlines
  p <- add_trace(p, data = data_variable %>% filter(Is_December), 
                 x = ~date, y = ~value,
                 marker = list(line = list(color = 'black', width = 2)),
                 type = 'scatter', mode = 'markers')

  # Layout settings
  p <- layout(p,
              title = paste("Monthly", gsub("_", " ", variable), "Evolution by City"),
              xaxis = list(title = "Date"),
              yaxis = list(title = paste(gsub("_", " ", variable)),
                        range = c(0, max(monthly_data[[variable]], na.rm = TRUE))),
              legend = list(orientation = 'v', x = 1.05, y = 1))
  
  return(p)
})

# Print the plots
for (plot in plot_list) {
  print(plot)
}
```

```{r}
final_monthly_data <- monthly_data %>%
  mutate(date = format(date, "%Y-%m")) %>%
  # Select all columns except "Is_December"
  select(-Is_December)

# Print the head of the dataset to check the changes
head(final_monthly_data)
```

```{r export dataset}
# Extract the minimum and maximum dates from the dataset
min_date <- min(final_monthly_data$date)
max_date <- max(final_monthly_data$date)

# Create the filename using the min and max dates
filename <- paste0("Score_Fiscal_Performance_cleaned_", min_date, "-", max_date, ".xlsx")

# Write the dataframe to an Excel file
write_xlsx(final_monthly_data, filename)
```

